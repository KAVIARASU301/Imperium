# Dynamic Trend Exit — Customizable Setup Panel

## The Concept (Institutional Context)
Institutions call this **"trend continuation mode"** — when a trade enters a strong directional
impulse, you **stop trying to time the exit** and instead let a regime breakdown signal pull
you out. The 3 knobs that govern this are:

| Knob | What it controls | Hardcoded Now |
|------|-----------------|---------------|
| ADX Unlock Min | Minimum ADX to enter trend-ride mode | `28.0` |
| ATR Ratio Min | Min normalized ATR (vol expansion) required | `1.15` |
| Confirm Bars | Consecutive qualifying bars before locking in | `3` |

---

## STEP 1 — Add widgets in `auto_trader_dialog.py`

Find the block where `dynamic_exit_open_drive_check` is created and **add below it**:

```python
# ── Dynamic Trend Exit Thresholds ─────────────────────────────────────────
from PySide6.QtWidgets import QDoubleSpinBox, QSpinBox

self.trend_exit_adx_min_input = QDoubleSpinBox()
self.trend_exit_adx_min_input.setRange(15.0, 45.0)
self.trend_exit_adx_min_input.setDecimals(1)
self.trend_exit_adx_min_input.setSingleStep(0.5)
self.trend_exit_adx_min_input.setValue(28.0)
self.trend_exit_adx_min_input.setStyleSheet(compact_spinbox_style)
self.trend_exit_adx_min_input.setToolTip(
    "Minimum ADX value required to activate trend-ride (unlock) mode.\n"
    "Higher = only unlock in very strong trends. Lower = more permissive.\n"
    "Institutional default: 28. Aggressive: 24. Conservative: 32."
)
self.trend_exit_adx_min_input.valueChanged.connect(self._on_automation_settings_changed)

self.trend_exit_atr_ratio_min_input = QDoubleSpinBox()
self.trend_exit_atr_ratio_min_input.setRange(0.80, 2.50)
self.trend_exit_atr_ratio_min_input.setDecimals(2)
self.trend_exit_atr_ratio_min_input.setSingleStep(0.05)
self.trend_exit_atr_ratio_min_input.setValue(1.15)
self.trend_exit_atr_ratio_min_input.setStyleSheet(compact_spinbox_style)
self.trend_exit_atr_ratio_min_input.setToolTip(
    "Minimum normalized ATR (current ATR / session baseline) to unlock trend mode.\n"
    "Ensures unlock only happens when volatility is expanding (trending market).\n"
    "Default: 1.15. Low vol sessions: try 1.05. High vol: try 1.25."
)
self.trend_exit_atr_ratio_min_input.valueChanged.connect(self._on_automation_settings_changed)

self.trend_exit_confirm_bars_input = QSpinBox()
self.trend_exit_confirm_bars_input.setRange(1, 8)
self.trend_exit_confirm_bars_input.setValue(3)
self.trend_exit_confirm_bars_input.setStyleSheet(compact_spinbox_style)
self.trend_exit_confirm_bars_input.setToolTip(
    "Consecutive qualifying bars (ADX + ATR both above threshold) required\n"
    "before switching to trend-ride mode. Prevents false unlock on a single spike bar.\n"
    "Default: 3. Faster reaction: 2. Slower/safer: 4-5."
)
self.trend_exit_confirm_bars_input.valueChanged.connect(self._on_automation_settings_changed)
```

---

## STEP 2 — Add to Setup Panel layout in `setup_panel.py`

Find the `auto_frm.addRow("Trend Exit On", trend_exit_row)` line and **add after it**:

```python
# ── Dynamic Trend Exit Thresholds group ──────────────────────────────────
from PySide6.QtWidgets import QFormLayout, QGroupBox

trend_thresh_widget = QWidget()
trend_thresh_lay = QFormLayout(trend_thresh_widget)
trend_thresh_lay.setContentsMargins(0, 2, 0, 2)
trend_thresh_lay.setSpacing(3)
trend_thresh_lay.setLabelAlignment(Qt.AlignmentFlag.AlignRight)

_w(self.trend_exit_adx_min_input)
_w(self.trend_exit_atr_ratio_min_input)
_w(self.trend_exit_confirm_bars_input)

trend_thresh_lay.addRow("ADX Min", self.trend_exit_adx_min_input)
trend_thresh_lay.addRow("ATR Ratio Min", self.trend_exit_atr_ratio_min_input)
trend_thresh_lay.addRow("Confirm Bars", self.trend_exit_confirm_bars_input)

auto_frm.addRow("Trend Exit Config", trend_thresh_widget)
```

---

## STEP 3 — Persist & Load in `auto_trader_dialog.py`

### In `_persist_automation_values()` — add to `values_to_persist` dict:
```python
"trend_exit_adx_min": float(self.trend_exit_adx_min_input.value()),
"trend_exit_atr_ratio_min": float(self.trend_exit_atr_ratio_min_input.value()),
"trend_exit_confirm_bars": int(self.trend_exit_confirm_bars_input.value()),
```

### In `_load_automation_values()` — add blockSignals + load:
```python
self.trend_exit_adx_min_input.blockSignals(True)
self.trend_exit_atr_ratio_min_input.blockSignals(True)
self.trend_exit_confirm_bars_input.blockSignals(True)

# ... (inside the load block, after other loads)
self.trend_exit_adx_min_input.setValue(_read_setting("trend_exit_adx_min", 28.0, float))
self.trend_exit_atr_ratio_min_input.setValue(_read_setting("trend_exit_atr_ratio_min", 1.15, float))
self.trend_exit_confirm_bars_input.setValue(_read_setting("trend_exit_confirm_bars", 3, int))

# ... (in unblockSignals section)
self.trend_exit_adx_min_input.blockSignals(False)
self.trend_exit_atr_ratio_min_input.blockSignals(False)
self.trend_exit_confirm_bars_input.blockSignals(False)
```

---

## STEP 4 — Emit in `signal_renderer.py` automation payload

Find `_emit_automation_state()` and add to the emitted dict:
```python
"trend_exit_adx_min": float(self.trend_exit_adx_min_input.value()),
"trend_exit_atr_ratio_min": float(self.trend_exit_atr_ratio_min_input.value()),
"trend_exit_confirm_bars": int(self.trend_exit_confirm_bars_input.value()),
```

---

## STEP 5 — Use in `cvd_automation_coordinator.py`

### Replace the hardcoded block (around line with `adx >= 28.0`):

**BEFORE (hardcoded):**
```python
trend_unlock = (
    trend_mode_eligible
    and not stacked_active
    and favorable_move >= unlock_profit_buffer
    and adx >= 28.0
    and atr_normalized >= 1.15
    and adx_slope > 0
    and vol_slope > 0
    and len(adx_hist) >= 3
    and len(vol_hist) >= 3
    and adx_hist[-1] > adx_hist[-2] > adx_hist[-3]
    and vol_hist[-1] > vol_hist[-2] > vol_hist[-3]
)
...
if unlock_bar_count >= 3 and active_trade.get("exit_mode") != "trend_unlock":
```

**AFTER (reads from payload):**
```python
# Read user-configured thresholds (with safe fallbacks to institutional defaults)
trend_exit_adx_min = _to_finite_float(active_trade.get("trend_exit_adx_min"), 28.0)
trend_exit_atr_ratio_min = _to_finite_float(active_trade.get("trend_exit_atr_ratio_min"), 1.15)
trend_exit_confirm_bars = int(active_trade.get("trend_exit_confirm_bars") or 3)

trend_unlock = (
    trend_mode_eligible
    and not stacked_active
    and favorable_move >= unlock_profit_buffer
    and adx >= trend_exit_adx_min          # ← was hardcoded 28.0
    and atr_normalized >= trend_exit_atr_ratio_min   # ← was hardcoded 1.15
    and adx_slope > 0
    and vol_slope > 0
    and len(adx_hist) >= 3
    and len(vol_hist) >= 3
    and adx_hist[-1] > adx_hist[-2] > adx_hist[-3]
    and vol_hist[-1] > vol_hist[-2] > vol_hist[-3]
)
...
if unlock_bar_count >= trend_exit_confirm_bars and active_trade.get("exit_mode") != "trend_unlock":
    # ↑ was hardcoded >= 3
```

### Also store the config in `market_state` when handling signals:

In `handle_signal()` where you merge payload into `market_state[token]`, make sure these keys pass through (they already will if you do a general merge — just verify the merge line includes all payload keys).

---

## Why This Matters (Institutional Logic)

- **ADX Min 28** → Standard "trend is real" threshold from Wilder's original work. Hedge funds often raise this to 30–35 for futures to avoid false trend locks
- **ATR Ratio 1.15** → Ensures you only ride when vol is expanding (a trending market breathes). Ratio < 1.0 = vol is contracting = trend is dying
- **Confirm Bars 3** → Classic **"3-bar rule"** from market microstructure. A single-bar spike isn't a regime — 3 consecutive bars showing the same structure is statistically significant

These are literally the same knobs a quant would tune in a **Kalman filter trend detector** or **Hidden Markov Model** regime classifier at the institutional level.